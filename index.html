<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Andrija Studios</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <h1>Andrija_studios</h1>

  <!-- Canvases -->
  <canvas id="trailCanvas"></canvas>
  <canvas id="sceneCanvas"></canvas>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
  <script src="script.js"></script>
</body>
</html>


<script>
  const sceneCanvas = document.getElementById("sceneCanvas");
  const trailCanvas = document.getElementById("trailCanvas");
  const sceneCtx = sceneCanvas.getContext("2d");
  const trailCtx = trailCanvas.getContext("2d");

  let width = window.innerWidth;
  let height = window.innerHeight;
  sceneCanvas.width = trailCanvas.width = width;
  sceneCanvas.height = trailCanvas.height = height;

  window.addEventListener("resize", () => {
    width = window.innerWidth;
    height = window.innerHeight;
    sceneCanvas.width = trailCanvas.width = width;
    sceneCanvas.height = trailCanvas.height = height;
    positionObjects();
  });

  // Cursor/Touch Trail
  let trail = [];
  function addToTrail(x, y) {
    trail.push({ x, y, alpha: 1.0 });
    if (trail.length > 100) trail.shift();
  }
  window.addEventListener("mousemove", e => addToTrail(e.clientX, e.clientY));
  window.addEventListener("touchmove", e => {
    const t = e.touches[0];
    addToTrail(t.clientX, t.clientY);
  }, { passive: true });

  function drawTrail() {
    trailCtx.clearRect(0, 0, width, height);
    for (let i = 1; i < trail.length; i++) {
      const p1 = trail[i - 1];
      const p2 = trail[i];
      trailCtx.strokeStyle = `rgba(255,255,255,${p2.alpha})`;
      trailCtx.lineWidth = 2;
      trailCtx.beginPath();
      trailCtx.moveTo(p1.x, p1.y);
      trailCtx.lineTo(p2.x, p2.y);
      trailCtx.stroke();
      p2.alpha -= 0.01;
    }
    trail = trail.filter(p => p.alpha > 0);
    requestAnimationFrame(drawTrail);
  }
  drawTrail();

  // Object3D class & shapes
  class Object3D {
    constructor(points, edges, label, centerX, centerY) {
      this.points = points;
      this.edges = edges;
      this.label = label;
      this.centerX = centerX;
      this.centerY = centerY;
      this.rotation = { x: 0, y: 0 };
      this.autoRotate = true;
    }
    rotatePoint(p, ax, ay) {
      let { x, y, z } = p;
      let y1 = y * Math.cos(ax) - z * Math.sin(ax);
      let z1 = y * Math.sin(ax) + z * Math.cos(ax);
      let x1 = x * Math.cos(ay) + z1 * Math.sin(ay);
      let z2 = -x * Math.sin(ay) + z1 * Math.cos(ay);
      return { x: x1, y: y1, z: z2 };
    }
    draw(ctx) {
      let projected = this.points.map(p => {
        let rotated = this.rotatePoint(p, this.rotation.x, this.rotation.y);
        let scale = 300 / (300 + rotated.z);
        return {
          x: this.centerX + rotated.x * scale,
          y: this.centerY + rotated.y * scale
        };
      });
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1.5;
      for (let edge of this.edges) {
        let [a, b] = edge;
        ctx.beginPath();
        ctx.moveTo(projected[a].x, projected[a].y);
        ctx.lineTo(projected[b].x, projected[b].y);
        ctx.stroke();
      }
      ctx.fillStyle = "white";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(this.label, this.centerX, this.centerY + 70);
    }
    update() {
      if (this.autoRotate) {
        this.rotation.x += 0.005;
        this.rotation.y += 0.01;
      }
    }
    isClicked(x, y) {
      return x > this.centerX - 60 && x < this.centerX + 60 &&
             y > this.centerY - 60 && y < this.centerY + 60;
    }
  }

const cube = new Object3D(
  [
    {x:-30,y:-30,z:-30}, {x:30,y:-30,z:-30}, {x:30,y:30,z:-30}, {x:-30,y:30,z:-30},
    {x:-30,y:-30,z:30},  {x:30,y:-30,z:30},  {x:30,y:30,z:30},  {x:-30,y:30,z:30}
  ],
  [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]],
  "About me", 0, 0
  );

 const pyramid = new Object3D(
  [
    {x:-30,y:30,z:-30},{x:30,y:30,z:-30},{x:30,y:30,z:30},{x:-30,y:30,z:30},{x:0,y:-40,z:0}
  ],
  [[0,1],[1,2],[2,3],[3,0],[0,4],[1,4],[2,4],[3,4]],
  "Projects", 0, 0
  );

const polygon = new Object3D(
  [
    {x:0,y:-40,z:0},{x:40,y:0,z:0},{x:20,y:40,z:30},
    {x:-20,y:40,z:30},{x:-40,y:0,z:0},{x:-20,y:-40,z:-30}
  ],
  [[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[2,5],[0,2]],
  "Resume", 0, 0
  );

  const objects = [cube, pyramid, polygon];

  function positionObjects() {
    if (width < 768) {
      cube.centerX = width / 2;
      cube.centerY = height / 5;
      pyramid.centerX = width / 2;
      pyramid.centerY = height / 2;
      polygon.centerX = width / 2;
      polygon.centerY = height * 4 / 5;
    } else {
      cube.centerX = width / 4;
      cube.centerY = height / 2;
      pyramid.centerX = width / 2;
      pyramid.centerY = height / 2;
      polygon.centerX = width * 3 / 4;
      polygon.centerY = height / 2;
    }
  }
  positionObjects();

  // Dragging support
  let draggingObject = null;
  let lastX, lastY;

  function getXY(e) {
    return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
  }

  function startDrag(e) {
    const { x, y } = getXY(e);
    for (let obj of objects) {
      if (obj.isClicked(x, y)) {
        draggingObject = obj;
        draggingObject.autoRotate = false;
        lastX = x;
        lastY = y;
        e.preventDefault();
        break;
      }
    }
  }

  function onDrag(e) {
    if (draggingObject) {
      const { x, y } = getXY(e);
      draggingObject.rotation.y += (x - lastX) * 0.01;
      draggingObject.rotation.x += (y - lastY) * 0.01;
      lastX = x;
      lastY = y;
      e.preventDefault();
    }
  }

  function endDrag() {
    if (draggingObject) {
      setTimeout(() => draggingObject.autoRotate = true, 2000);
      draggingObject = null;
    }
  }

  sceneCanvas.addEventListener("mousedown", startDrag);
  sceneCanvas.addEventListener("touchstart", startDrag, { passive: false });
  sceneCanvas.addEventListener("mousemove", onDrag);
  sceneCanvas.addEventListener("touchmove", onDrag, { passive: false });
  sceneCanvas.addEventListener("mouseup", endDrag);
  sceneCanvas.addEventListener("touchend", endDrag);

  // Click handling
 function handleClick(e) {
  const { x, y } = getXY(e);
  for (let obj of objects) {
    if (obj.isClicked(x, y)) {
      if (obj.label === "About me") {
        window.location.href = "about.html";
      } else if (obj.label === "Projects") {
        window.location.href = "projects.html";
      } else if (obj.label === "Resume") {
        window.location.href = "resume.html";
      }
    }
  }
}
  
  sceneCanvas.addEventListener("click", handleClick);
  sceneCanvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      const touch = e.touches[0];
      setTimeout(() => handleClick({ clientX: touch.clientX, clientY: touch.clientY }), 0);
    }
  }, { passive: true });

  // Animation loop
  function animate() {
    sceneCtx.clearRect(0, 0, width, height);
    for (let obj of objects) {
      obj.update();
      obj.draw(sceneCtx);
    }
    requestAnimationFrame(animate);
  }
  animate();
</script>

