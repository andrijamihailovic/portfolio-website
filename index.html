<!DOCTYPE html> 
<html lang="en"> 
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content= "IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Andrija MihailoviÄ‡</title>
    <link rel="icon" type="images/x-icon" href="images/favicon.ico" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>Andrija_studios</header>
  <canvas id="scene"></canvas>
  <script src="script.js"></script>
</body>
</html>

</script>

<script>

const canvas = document.getElementById("scene");
const ctx = canvas.getContext("2d");
resize();
window.addEventListener("resize", resize);

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

// === OBJECTS ===
class Object3D {
  constructor(points, edges, label, centerX, centerY) {
    this.points = points;
    this.edges = edges;
    this.label = label;
    this.centerX = centerX;
    this.centerY = centerY;
    this.rotation = { x: 0, y: 0 };
    this.autoRotate = true;
  }

  rotatePoint(p, angleX, angleY) {
    let { x, y, z } = p;
    // X-axis rotation
    let cosX = Math.cos(angleX), sinX = Math.sin(angleX);
    let y1 = y * cosX - z * sinX;
    let z1 = y * sinX + z * cosX;

    // Y-axis rotation
    let cosY = Math.cos(angleY), sinY = Math.sin(angleY);
    let x1 = x * cosY + z1 * sinY;
    let z2 = -x * sinY + z1 * cosY;

    return { x: x1, y: y1, z: z2 };
  }

  draw(ctx) {
    let projected = this.points.map(p => {
      let rotated = this.rotatePoint(p, this.rotation.x, this.rotation.y);
      let scale = 500 / (500 + rotated.z);
      return {
        x: this.centerX + rotated.x * scale,
        y: this.centerY + rotated.y * scale
      };
    });

    ctx.strokeStyle = "white";
    ctx.lineWidth = 1;
    for (let edge of this.edges) {
      let [a, b] = edge;
      ctx.beginPath();
      ctx.moveTo(projected[a].x, projected[a].y);
      ctx.lineTo(projected[b].x, projected[b].y);
      ctx.stroke();
    }

    // Label
    ctx.fillStyle = "white";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(this.label, this.centerX, this.centerY + 70);
  }

  update() {
    if (this.autoRotate) {
      this.rotation.y += 0.01;
      this.rotation.x += 0.005;
    }
  }
}

// === SHAPE DATA ===

// Cube
const cubePoints = [
  { x: -30, y: -30, z: -30 },
  { x:  30, y: -30, z: -30 },
  { x:  30, y:  30, z: -30 },
  { x: -30, y:  30, z: -30 },
  { x: -30, y: -30, z:  30 },
  { x:  30, y: -30, z:  30 },
  { x:  30, y:  30, z:  30 },
  { x: -30, y:  30, z:  30 },
];
const cubeEdges = [
  [0,1],[1,2],[2,3],[3,0],
  [4,5],[5,6],[6,7],[7,4],
  [0,4],[1,5],[2,6],[3,7]
];

// Pyramid
const pyramidPoints = [
  { x: -30, y: 30, z: -30 },
  { x:  30, y: 30, z: -30 },
  { x:  30, y: 30, z:  30 },
  { x: -30, y: 30, z:  30 },
  { x: 0,   y: -40, z: 0 }  // tip
];
const pyramidEdges = [
  [0,1],[1,2],[2,3],[3,0],
  [0,4],[1,4],[2,4],[3,4]
];

// Custom polygon (weird shape)
const polygonPoints = [
  { x:  0, y: -40, z: 0 },
  { x: 40, y: 0, z: 0 },
  { x: 20, y: 40, z: 30 },
  { x: -20, y: 40, z: 30 },
  { x: -40, y: 0, z: 0 },
  { x: -20, y: -40, z: -30 },
];
const polygonEdges = [
  [0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[2,5],[0,2]
];

// Instantiate objects
const objects = [
  new Object3D(cubePoints, cubeEdges, "Product Design", canvas.width / 4, canvas.height / 2),
  new Object3D(pyramidPoints, pyramidEdges, "Graphic Design", canvas.width / 2, canvas.height / 2),
  new Object3D(polygonPoints, polygonEdges, "Motion Design", canvas.width * 3 / 4, canvas.height / 2),
];

// === INTERACTION ===
let draggingObject = null;
let lastX, lastY;

canvas.addEventListener("mousedown", e => {
  const x = e.clientX;
  const y = e.clientY;

  for (let obj of objects) {
    if (
      x > obj.centerX - 50 && x < obj.centerX + 50 &&
      y > obj.centerY - 50 && y < obj.centerY + 50
    ) {
      draggingObject = obj;
      draggingObject.autoRotate = false;
      lastX = x;
      lastY = y;
      break;
    }
  }
});

canvas.addEventListener("mousemove", e => {
  if (draggingObject) {
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    draggingObject.rotation.y += dx * 0.01;
    draggingObject.rotation.x += dy * 0.01;
    lastX = e.clientX;
    lastY = e.clientY;
  }
});

canvas.addEventListener("mouseup", () => {
  if (draggingObject) {
    setTimeout(() => draggingObject.autoRotate = true, 2000);
    draggingObject = null;
  }
});

// === RENDER LOOP ===
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let obj of objects) {
    obj.update();
    obj.draw(ctx);
  }
  requestAnimationFrame(animate);
}
animate();

</script>

</body> 
</html>

    
