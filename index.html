<!DOCTYPE html> 
<html lang="en"> 
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content= "IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Andrija MihailoviÄ‡</title>
    <link rel="icon" type="images/x-icon" href="images/favicon.ico" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Andrija_studios</h1>
  <canvas id="trailCanvas"></canvas>
  <canvas id="sceneCanvas"></canvas>
  <script src="script.js"></script>
</body>
    <body onload="document.body.classList.add('fade-in')">
</html>

</script>

<script>

// === Canvas Setup ===
const sceneCanvas = document.getElementById("sceneCanvas");
const trailCanvas = document.getElementById("trailCanvas");
const sceneCtx = sceneCanvas.getContext("2d");
const trailCtx = trailCanvas.getContext("2d");

let width = window.innerWidth;
let height = window.innerHeight;
sceneCanvas.width = trailCanvas.width = width;
sceneCanvas.height = trailCanvas.height = height;

window.addEventListener("resize", () => {
  width = window.innerWidth;
  height = window.innerHeight;
  sceneCanvas.width = trailCanvas.width = width;
  sceneCanvas.height = trailCanvas.height = height;
  positionObjects();
});

// === Cursor Trail ===
let trail = [];
function addToTrail(x, y) {
  trail.push({ x, y, alpha: 1.0 });
  if (trail.length > 100) trail.shift();
}
window.addEventListener("mousemove", e => addToTrail(e.clientX, e.clientY));
window.addEventListener("touchmove", e => {
  const t = e.touches[0];
  addToTrail(t.clientX, t.clientY);
}, { passive: true });

function drawTrail() {
  trailCtx.clearRect(0, 0, width, height);
  for (let i = 1; i < trail.length; i++) {
    const p1 = trail[i - 1];
    const p2 = trail[i];
    trailCtx.strokeStyle = `rgba(255,255,255,${p2.alpha})`;
    trailCtx.lineWidth = 2;
    trailCtx.beginPath();
    trailCtx.moveTo(p1.x, p1.y);
    trailCtx.lineTo(p2.x, p2.y);
    trailCtx.stroke();
    p2.alpha -= 0.01;
  }
  trail = trail.filter(p => p.alpha > 0);
  requestAnimationFrame(drawTrail);
}
drawTrail();

// === Object3D ===
class Object3D {
  constructor(points, edges, label, centerX, centerY) {
    this.points = points;
    this.edges = edges;
    this.label = label;
    this.centerX = centerX;
    this.centerY = centerY;
    this.rotation = { x: 0, y: 0 };
    this.autoRotate = true;
  }
  rotatePoint(p, ax, ay) {
    let { x, y, z } = p;
    let y1 = y * Math.cos(ax) - z * Math.sin(ax);
    let z1 = y * Math.sin(ax) + z * Math.cos(ax);
    let x1 = x * Math.cos(ay) + z1 * Math.sin(ay);
    let z2 = -x * Math.sin(ay) + z1 * Math.cos(ay);
    return { x: x1, y: y1, z: z2 };
  }
  draw(ctx, hovered = false) {
    let projected = this.points.map(p => {
      let rotated = this.rotatePoint(p, this.rotation.x, this.rotation.y);
      let scale = 500 / (500 + rotated.z);
      return {
        x: this.centerX + rotated.x * scale * (hovered ? 1.1 : 1),
        y: this.centerY + rotated.y * scale * (hovered ? 1.1 : 1)
      };
    });
    ctx.strokeStyle = hovered ? "white" : "#ddd";
    ctx.lineWidth = hovered ? 2.5 : 1.2;
    ctx.shadowColor = hovered ? "white" : "transparent";
    ctx.shadowBlur = hovered ? 10 : 0;
    for (let edge of this.edges) {
      let [a, b] = edge;
      ctx.beginPath();
      ctx.moveTo(projected[a].x, projected[a].y);
      ctx.lineTo(projected[b].x, projected[b].y);
      ctx.stroke();
    }
    ctx.shadowBlur = 0;
    ctx.fillStyle = "white";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(this.label, this.centerX, this.centerY + 70);
  }
  update() {
    if (this.autoRotate) {
      this.rotation.x += 0.005;
      this.rotation.y += 0.01;
    }
  }
  isClicked(x, y) {
    return x > this.centerX - 60 && x < this.centerX + 60 &&
           y > this.centerY - 60 && y < this.centerY + 60;
  }
}

// === 3D Objects ===
const cube = new Object3D(
  [
    {x:-30,y:-30,z:-30},{x:30,y:-30,z:-30},{x:30,y:30,z:-30},{x:-30,y:30,z:-30},
    {x:-30,y:-30,z:30},{x:30,y:-30,z:30},{x:30,y:30,z:30},{x:-30,y:30,z:30}
  ],
  [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]],
  "Product Design", 0, 0
);
const pyramid = new Object3D(
  [
    {x:-30,y:30,z:-30},{x:30,y:30,z:-30},{x:30,y:30,z:30},{x:-30,y:30,z:30},{x:0,y:-40,z:0}
  ],
  [[0,1],[1,2],[2,3],[3,0],[0,4],[1,4],[2,4],[3,4]],
  "Graphic Design", 0, 0
);
const polygon = new Object3D(
  [
    {x:0,y:-40,z:0},{x:40,y:0,z:0},{x:20,y:40,z:30},
    {x:-20,y:40,z:30},{x:-40,y:0,z:0},{x:-20,y:-40,z:-30}
  ],
  [[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[2,5],[0,2]],
  "Motion Design", 0, 0
);
const objects = [cube, pyramid, polygon];

function positionObjects() {
  if (width < 768) {
    cube.centerX = width / 2;
    cube.centerY = height / 5;
    pyramid.centerX = width / 2;
    pyramid.centerY = height / 2;
    polygon.centerX = width / 2;
    polygon.centerY = height * 4 / 5;
  } else {
    cube.centerX = width / 4;
    cube.centerY = height / 2;
    pyramid.centerX = width / 2;
    pyramid.centerY = height / 2;
    polygon.centerX = width * 3 / 4;
    polygon.centerY = height / 2;
  }
}
positionObjects();

// === Dragging ===
let draggingObject = null;
let lastX, lastY;
function getXY(e) {
  return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
}
function startDrag(e) {
  const { x, y } = getXY(e);
  for (let obj of objects) {
    if (obj.isClicked(x, y)) {
      draggingObject = obj;
      draggingObject.autoRotate = false;
      lastX = x;
      lastY = y;
      e.preventDefault();
      break;
    }
  }
}
function onDrag(e) {
  if (draggingObject) {
    const { x, y } = getXY(e);
    draggingObject.rotation.y += (x - lastX) * 0.01;
    draggingObject.rotation.x += (y - lastY) * 0.01;
    lastX = x;
    lastY = y;
    e.preventDefault();
  }
}
function endDrag() {
  if (draggingObject) {
    setTimeout(() => draggingObject.autoRotate = true, 2000);
    draggingObject = null;
  }
}
sceneCanvas.addEventListener("mousedown", startDrag);
sceneCanvas.addEventListener("touchstart", startDrag, { passive: false });
sceneCanvas.addEventListener("mousemove", onDrag);
sceneCanvas.addEventListener("touchmove", onDrag, { passive: false });
sceneCanvas.addEventListener("mouseup", endDrag);
sceneCanvas.addEventListener("touchend", endDrag);

// === Hover + Click ===
let mouse = { x: null, y: null };
sceneCanvas.addEventListener("mousemove", e => { mouse.x = e.clientX; mouse.y = e.clientY; });
sceneCanvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  mouse.x = t.clientX;
  mouse.y = t.clientY;
});
sceneCanvas.addEventListener("mouseleave", () => { mouse.x = null; mouse.y = null; });

function transitionToPage(url) {
  document.body.classList.remove("fade-in");
  document.body.classList.add("fade-out");
  setTimeout(() => window.location.href = url, 500);
}

function handleClick(e) {
  const { x, y } = getXY(e);
  for (let obj of objects) {
    if (obj.isClicked(x, y)) {
      if (obj.label.includes("Product")) transitionToPage("product.html");
      if (obj.label.includes("Graphic")) transitionToPage("graphic.html");
      if (obj.label.includes("Motion")) transitionToPage("motion.html");
    }
  }
}
sceneCanvas.addEventListener("click", handleClick);
sceneCanvas.addEventListener("touchstart", e => {
  if (e.touches.length === 1) {
    const t = e.touches[0];
    setTimeout(() => handleClick({ clientX: t.clientX, clientY: t.clientY }), 0);
  }
}, { passive: true });

// === Animate ===
function animate() {
  sceneCtx.clearRect(0, 0, width, height);
  let hoverTarget = null;
  for (let obj of objects) {
    obj.update();
    if (mouse.x && mouse.y && obj.isClicked(mouse.x, mouse.y)) {
      hoverTarget = obj;
    }
  }
  for (let obj of objects) {
    obj.draw(sceneCtx, obj === hoverTarget);
  }
  requestAnimationFrame(animate);
}
animate();


    

</script>

</body> 
</html>

    
