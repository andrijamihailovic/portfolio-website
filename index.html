<!DOCTYPE html> 
<html lang="en"> 
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content= "IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Andrija MihailoviÄ‡</title>
    <link rel="icon" type="images/x-icon" href="images/favicon.ico" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>Andrija_studios</header>
  <canvas id="spikeCanvas"></canvas>
  <canvas id="trailCanvas"></canvas>
  <script src="script.js"></script>
</body>
</html>

</script>

<script>

// Canvas setup
const spikeCanvas = document.getElementById('spikeCanvas');
const trailCanvas = document.getElementById('trailCanvas');
const spikeCtx = spikeCanvas.getContext('2d');
const trailCtx = trailCanvas.getContext('2d');

function resizeCanvas() {
  spikeCanvas.width = trailCanvas.width = window.innerWidth;
  spikeCanvas.height = trailCanvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Mouse trail
let trail = [];
window.addEventListener("mousemove", (e) => {
  trail.push({ x: e.clientX, y: e.clientY, alpha: 1.0 });
});
function drawTrail() {
  trailCtx.clearRect(0, 0, trailCanvas.width, trailCanvas.height);
  for (let i = 1; i < trail.length; i++) {
    const p1 = trail[i - 1];
    const p2 = trail[i];
    trailCtx.strokeStyle = `rgba(255, 255, 255, ${p2.alpha})`;
    trailCtx.lineWidth = 2;
    trailCtx.beginPath();
    trailCtx.moveTo(p1.x, p1.y);
    trailCtx.lineTo(p2.x, p2.y);
    trailCtx.stroke();
    p2.alpha -= 0.02;
  }
  trail = trail.filter(p => p.alpha > 0);
  requestAnimationFrame(drawTrail);
}
drawTrail();

// Spike ball
let angleX = 0;
let angleY = 0;
let autoRotate = true;
let isDragging = false;
let lastX, lastY;

let points = [];
const radius = 100;
const spikes = 200;

for (let i = 0; i < spikes; i++) {
  let theta = Math.random() * 2 * Math.PI;
  let phi = Math.acos(2 * Math.random() - 1);
  let r = radius + Math.random() * 30;
  points.push({
    x: r * Math.sin(phi) * Math.cos(theta),
    y: r * Math.sin(phi) * Math.sin(theta),
    z: r * Math.cos(phi),
  });
}

function rotate(point, ax, ay) {
  let x = point.x;
  let y = point.y * Math.cos(ax) - point.z * Math.sin(ax);
  let z = point.y * Math.sin(ax) + point.z * Math.cos(ax);

  let newX = x * Math.cos(ay) - z * Math.sin(ay);
  let newZ = x * Math.sin(ay) + z * Math.cos(ay);
  return { x: newX, y: y, z: newZ };
}

function drawBall() {
  spikeCtx.clearRect(0, 0, spikeCanvas.width, spikeCanvas.height);
  const centerX = spikeCanvas.width / 2;
  const centerY = spikeCanvas.height / 2;

  for (let point of points) {
    let rotated = rotate(point, angleX, angleY);
    let scale = 400 / (400 + rotated.z);
    let x2D = centerX + rotated.x * scale;
    let y2D = centerY + rotated.y * scale;

    spikeCtx.beginPath();
    spikeCtx.arc(x2D, y2D, 2, 0, Math.PI * 2);
    spikeCtx.fillStyle = "white";
    spikeCtx.fill();
  }

  if (autoRotate) {
    angleY += 0.005;
    angleX += 0.003;
  }

  requestAnimationFrame(drawBall);
}
drawBall();

// Drag interaction
spikeCanvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  autoRotate = false;
  lastX = e.clientX;
  lastY = e.clientY;
});

window.addEventListener("mousemove", (e) => {
  if (isDragging) {
    let dx = e.clientX - lastX;
    let dy = e.clientY - lastY;
    angleY += dx * 0.01;
    angleX += dy * 0.01;
    lastX = e.clientX;
    lastY = e.clientY;
  }
});

window.addEventListener("mouseup", () => {
  isDragging = false;
  setTimeout(() => autoRotate = true, 3000);
});

</script>

</body> 
</html>

    
